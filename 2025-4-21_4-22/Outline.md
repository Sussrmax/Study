# 18:36

## 右值引用
**右值**: **表示临时对象**或**无法取地址的值**(如字面量，函数返回的临时对象等); 其中**右值**又分为 **春右值** 和 **将亡值**。<br> **纯右值**: 如字面值(0，2.1，2), 临时对象(string("Hello")) <br> **将亡值**: 某些将要销毁的对象，如通过 move 转换的对象

**右值引用**: 所谓右值引用，就是必须绑定到 **右值的引用**，通过 && 来获得右值引用

**绑定特性**:
1. **左值引用**: 不能将其绑定到要求转换的表达式，字面常量 或是 返回右值的表达式， 可以将一个const对象绑定到右值上
2. **右值引用**: 与左值引用完全相反，但不能将一个右值引用绑定到一个左值上；

**左值持久**，**右值短暂**，右值引用指向 **将要被销毁的对象**，我们可以从绑定到右值引用的对象"**窃取**" 状态

变量是左值，**右值引用类型的变量也属于一个左值**, 右值引用不能绑定到一个左值上

**move函数**: 用于将一个左值转换为对应的右值引用类型

---

## 移动构造函数 和 移动赋值运算符
不抛出异常的 **移动构造函数** 和 **移动赋值运算符** 必须标记为 **noexcept** 
1. 为什么要用 noexcept 呢？<br> 举例: vector 的 push_back 在面临容量不足的情况下会扩容，此时需要将就空间中的元素转移到新空间中，如果 **移动构造函数** 不声明为 **noexcept** 的话会让编译器认为该 **移动构造函数** 可能存在异常从而调用的相对安全的 **拷贝构造函数** 而不是 **移动构造函数**。
   
只有当一个类 **没有** 定义任何自己版本的 **拷贝控制成员**，**且它的所有数据成员都能移动构造或移动赋值时**，编译器才会为它合成移动构造函数或移动赋值运算符。

定义了一个 **移动构造函数** 或 **移动赋值运算符的类**必须也定义自己的 **拷贝操作**，否则，这些成员默认地被定义为 **删除的**

如果一个类既有 **移动构造函数/运算符** 又有 **拷贝构造函数/运算符**，则调用规则根据**函数匹配规则**来确定使用哪个构造函数
如果一个类有一个可用的**拷贝构造函数**而没有**移动构造函数**，则其对象是通过**拷贝构造函数来“移动”的**，**拷贝赋值运算符和移动赋值运算符**情况类似

如果一个类既有 **移动构造函数** 又有 **拷贝构造函数**，那么定义的 **赋值运算符** 则拥有了 **移动赋值运算符** 和 **拷贝赋值运算符** 的特性

**移动迭代器**: **make_move_iterator**, 移动迭代器的解引用运算符生成一个 **右值引用**

---

## 右值引用 和 成员函数

一般来说，当我们希望从**实参“窃取”数据**时，通常传递一个**右值引用**，为了达到此目的**实参不能是const 的**
类似的，从一个对象进行**拷贝的操作**不应该改变该对象，因此，**实参是 const 的** 
**注意**: 区分移动和拷贝的重载函数通常有一个版本接受一个 const T&, 而另一个版本接受一个 T&&

**引用限定符**
**引用限定符** 是附加在成员函数声明后的标记，用于指定该函数只能被特定类型的对象调用。
1. & : 左值限定符，表示函数只能被左值对象调用
2. && : 右值限定符，表示函数只能被右值对象调用
3. 如果与 const 搭配使用，那么必须紧跟 const 后面

如果一个**成员函数有引用限定符**，则具有**相同参数列表**的**所有版本**都必须有**引用限定符**
        


       

        






