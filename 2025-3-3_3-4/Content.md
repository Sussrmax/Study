# 22:39
* 这两天课多而且散，没多少时间学(懒，借口), 这两天完成了两道算法题，还是有了不错的了解，题目链接: https://blog.csdn.net/AC__dream/article/details/130048959 和 题目链接: https://www.luogu.com.cn/problem/P1162
* 两道算法题都是关于 BFS 的，同时也给了我一个不错的解题思路，那就是通过外围增加一个新处理来统一情况，两道算法题的考点大致一样。
* 同时也长记性了，耍帅写的 nx = (nx >= 0) && (nx <= n + 1) ? nx : p_x;  这样写是错误的，可能会导致重复点的操作，例如: (0, 0) 向左移动(-1, 0) 越界， nx 被修正为 0，结果还是(0, 0) 。 因此还是推荐老实的写法 if(nx >= 0 && nx <= n + 1 && ny >= 0 && ny <= n + 1)
* 一道算法题刷几个小时，这就是新手吗，万事开头难，这也太爽了吧
  
# 3月5日补充
## 10:43
* 关于昨天的第一道算法题中出现了一些疑点困住了我，在 bfs_islands 函数中，我设置的入队条件为 if(mpas[_nx][_ny] == '0' || sign[nx][ny] == 1) continue;  <br> 本意是说如果该方向碰到海水或者已经走过了那么就跳过，但是这么该之后怎么也算不出来答案，硬是改成 if(maps[nx][ny] == '1' && sign[nx][ny] == 0) 才能解出来，我想想前者的逻辑也是对的为什么无法解出来呢，<br> 后来在开始BFS 岛屿时，打印了地图和标记图发现，maps 外圈是空的，因为使用memset(&maps, 0, sizeof maps) char 数组 maps 初始化为 全 '0' 的字符，但这样写不能达到这个效果memset(&maps, 0, sizeof maps) 改成 memset(&maps, '0', sizeof maps) 就正确了
* 为什么memset(&maps, 0, sizeof mpas) 不正确，而使用 memset(&maps, '0', sizeof maps) 却正确呢,因为: 
<br> 0 - 31 和 127 为控制字符: 这些字符通常不可见，用于控制设备的行为。 例如: 127: DEL(删除)
<br> 32 - 126 为 可打印字符:
<br> 32: 空格
<br> 48 - 57: 数字 '0' 到 '9' 
<br> 65 - 90: 大写字母 'A' 到 'Z'
<br> 97 - 122: 小写字母 'a' 到 'z'
<br> 128 - 255: 为扩展字符