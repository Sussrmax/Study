# 17:19

## 关联容器
1. 关联容器共有 8 种，但是从整体上分为两类，一类是**map类型**，另一类是**set类型**, 从功能上分为三种，一种是有序不包含重复关键字的(map/set), 一种是无序的(unordered), 一种是包含重复关键字的(multi)。
2. 我们可以提供自己定义的操作来替代关键字上的 < 运算符，但所提供的操作必须在关键字类型上定义 **严格弱序(小于等于)** <br>如果一个类型定义了 “行为正常" 的 < 运算符，那么它可以用作关键字类型。
3. 可以自定义**关联容器**的比较方式，为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型, 所提供的 比较操作类型 是一种 函数指针类型
4. key_type : 此容器的关键字类型 <br> mapped_type : 此关键字关联的类型，只适用于 map <br> value_type : 对于set, key_type 和 value_type 是一样的, 对于map ,则为 pair<const key_type, mapped_type>
5. **关联容器**的**关键字**是无法修改的，map 存储的是**键值对**因此可以修改**键**对应的**值**，set存储的是**键**因此无法修改。
6. **无序容器**在存储上组织为一组桶，每个桶保存零个或多个元素，使用**哈希函数**将元素映射到桶 <br> 无序容器使用 关键字类型 的 ==运算符 和 一个 hash<key_type> 类型的对象来组织元素 <br> 我们不能直接定义 关键字类型 为 自定义类类型，需要提供我们自己的hash 模板版本
---

## 智能指针
1. 三类智能指针: shared_ptr, unique_ptr, weak_ptr <br> **shared_ptr** 允许多个指针指向同一个对象 <br> **unique_ptr** 只允许一个指针指向一个对象 <br> **weak_ptr** 是一种不控制所指向对象生存期的智能指针， 配合这 **shared_ptr** 使用并依赖它。
2. 智能指针的构造函数是**explicit**的，意味着不能进行**隐式转换**，因此不能将**内置指针**隐式转化为**智能指针**
3. 最安全的使用智能指针的方式是调用函数**make_shared / unique**.
4. 当通过**new**申请内存时可以会出现**分配失败**的情况，此时会返回一个**空指针**并抛出**异常**，但通过**nothrow**可以使在分配失败后不抛出异常
5. 通过**delete p 或 delete [] p** 来释放一个堆对象或数组，**p指针**必须是动态内存分配的内存或者是一个空指针。<br> 在delete 过后，指针就会变成**空悬指针**，即**指向一块曾经保存数据对象但现在已经无效的内存的指针**
6. 动态内存分配的**const对象**必须进行**初始化**
7. unique_ptr 不支持**普通的拷贝**或**赋值**操作，但有一个例外，那就是我们可以**拷贝或赋值一个将要销毁的unique_ptr**，常见的例子就是函数返回一个unique_ptr 
8. allocator 类帮助我们将**内存分配** 和 **对象构造**分离开。 <br> 我们只能对真正构造了的元素进行destroy 将元素销毁操作，一旦销毁可以重新使用这部分内存来保存其他对象，也可以通过 deallocate 来将内存归还给系统
具体见: E:\Study\CPP\Base_2\Book\SmartPointer.cpp