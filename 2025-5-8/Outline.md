# 记录时间: 21点05分

## 面向对象编程

### 继承与派生
**类派生列表**，用于指明类是从哪个基类继承而来的，用 **逗号** 分隔开 

**虚函数**: **virtual** , 用于指明该函数是一个 **虚函数**，虚函数是一个在基类中声明的函数，可以在派生类中重写。虚函数的作用是 **实现多态性**。

对于派生类继承的虚函数，必须在派生类内部 **重新定义所有的虚函数进行声明**，可以在函数之前加上 **virtual关键字**，也可以不加。可以在新参列表后面加上 **override 关键字**，表示该函数是一个重写的虚函数。

派生类通常覆盖它继承的虚函数，**如果没有覆盖其基类中的某个虚函数，则该会使用基类中的版本**

**每个类控制它自己的成员初始化过程**,所以初始化派生类时会调用基类的构造函数

**首先初始化基类的部分**，然后按照 **声明的顺序** 依次初始化派生类的成员

### 继承与静态成员
如果基类定义了 **一个静态成员**，那么所有继承中 **共用** 这个静态成员。静态成员在 **内存中只存在一份**，所有对象共享这份静态成员。
静态成员遵循 **访问控制规则**

### 类的声明
被用作基类的类必须 **已经定义而非仅仅声明**，类的声明**不包含 派生类列表**

### 防止继承
当一个类**不希望被继承时**，可以在类名后面加上 **关键字final,表示该类是最终类**

### 继承与智能指针
和内置指针一样，智能指针类也支持 **派生类向基类的类型转换**, 我们可以将一个派生类对象的指针存储在一个基类的智能指针内

### 继承关系的转换规则
从 **派生类向基类的类型转换** 只 **对指针或引用类型有效**
基类向派生类 **不存在隐式类型转换**
和任何其他成员一样，派生类向基类的类型转换 **也可能由于访问受限而变得不可行**


### 虚函数
**一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数**

派生类覆盖基类的虚函数，**它的形参表必须与基类的虚函数的形参表完全相同**
返回值类型可以不同，但不推荐这样做, **除非虚函数返回的类型是类本身的指针或引用**

**override**
用来注明 **某个函数是基类的虚函数的重写版本**
如果**重载了一个虚函数，这将会与原来基类中的函数独立开来**，因此为了避免错误，建议在重写的虚函数后使用override

**final**
如果将一个函数声明为final, 则表示该函数**不能被重写，也不能被覆盖, 但可以重载**

**回避虚函数机制**
通过 **作用域运算符** 可以在 **派生类中调用 基类的虚函数**
只有 **成员函数(或友元)中的 才需要使用 作用域运算符(::) 来回避 虚函数机制**
如果不使用 **作用域运算符 则可能会导致无限递归**
    
        

