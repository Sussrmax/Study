# 20:06
* 完成了昨日两道算法题的复习，还是得感叹以下，昨日那道动态规划的题，虽然说是爬楼梯的换皮，但是最终的思路属实没想到啊
* 今日完成算法题: ://leetcode.cn/problems/count-ways-to-build-good-strings/description/ 也是爬楼梯的换皮，想了半天也还是没想到，悲！
* 看了看c++primer 的 容器库概览，有意思的点: 赋值相关运算会导致指向左边容器内部的迭代器，引用和指针失效。使用swap 则不会出现这样的问题(容器类型为 array 和 string的除外);
* 简要说明: 因为赋值相关的运算可能会导致将原数据的空间释放，然后重新申请新的空间来存放新数据(例如:将大容器赋值给一个小容器)。指针等指向原来的空间，如果被原来的空间被释放掉则会导致指针指空，因此会失效。(来自Grok)
* 除array 外，swap 不对任何元素进行拷贝，删除或插入操作，只是会交换容器的内部数据结构
* STL中，对常量对象使用begin()等获取迭代器的操作得到的是const_iterator,而不需要使用cbegin()版本。而对非常量对象，想要获取const_iterator 版本则需要使用cbegin();
* 通过迭代器，可以实现跨容器，跨容器元素类型实现赋值(只要两容器类型可以实现类型转化)。例如: list<_int> list;  deque<_float> deque(list.begin(), list.end());  因为int 可以转化为 float;
* 迭代器范围设置为左闭右开区间，即[begin, end)

一个文件夹才存一个文件，得想想加些内容上来，不然白造文件夹了